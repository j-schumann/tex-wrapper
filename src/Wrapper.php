<?php

/**
 * @copyright   (c) 2017, Vrok
 * @license     MIT License (http://www.opensource.org/licenses/mit-license.php)
 * @author      Jakob Schumann <schumann@vrok.de>
 */

namespace TexWrapper;

/**
 * Stores the given LaTeX and generates a PDF file from it.
 */
class Wrapper
{
    /**
     * Command to use to execute PDFLaTeX.
     *
     * @var string
     */
    protected $command = 'pdflatex --file-line-error';

    /**
     * Filename used to store the TEX.
     *
     * @var string
     */
    protected $filename = null;

    /**
     * Flag for the destructor to clean up if true.
     *
     * @var bool
     */
    protected $isTempfile = false;

    /**
     * List of errors that occured while building the PDF
     *
     * @var array
     */
    protected $errors = [];

    /**
     * Console output generated by pdflatex.
     *
     * @var string
     */
    protected $log = '';

    /**
     * Class constructor - stores the given filename.
     *
     * @param string $filename  (optional) if given the TEX is stored in this file and
     *     kept, if empty a temporary file is used and deleted on destruction
     */
    public function __construct(string $filename = null)
    {
        if (! $filename) {
            // tempnam requires a dir, we can not use ini_get('upload_tmp_dir')
            // as this would not be set in CLI, sys_get_temp_dir() can probably
            // not be changed to return a vhost specific path,
            // @see http://stackoverflow.com/questions/13186069/sys-get-temp-dir-in-shared-hosting-environment
            // tempnam falls back to the system tmp if the given directory does
            // not exist but may have problems if it is outside the open_basedir
            // restriction
            $dir = sys_get_temp_dir();
            $filename = tempnam($dir, 'textemp');
            $this->isTempfile = true;
        }

        $this->filename = $filename;
    }

    /**
     * If the instance created a temporary file remove it now.
     */
    public function __destruct()
    {
        if ($this->isTempfile) {
            $this->deleteTex();
        }
    }

    /**
     * Returns the current pdflatex command.
     *
     * @return string
     */
    public function getCommand() : string
    {
        return $this->command;
    }

    /**
     * Allows to set a custom pdflatex command. May contain full path if it's
     * not within the $PATH environment. Can be used to modify the command, e.g.
     * if you have installed texfot. The --interaction and --output-directory
     * parameter are appended.
     *
     * @param string $cmd
     */
    public function setCommand(string $cmd)
    {
        $this->command = $cmd;
    }

    /**
     * Stores the given Tex content in the current file.
     *
     * @param string $tex
     * @return boolean      true if the file was written, else false
     */
    public function saveTex(string $tex) : bool
    {
        return file_put_contents($this->filename, $tex) !== false;
    }

    /**
     * Deletes the tex file for cleanup.
     */
    public function deleteTex()
    {
        @unlink($this->filename);
    }

    /**
     * Generates a pdf file from the current LaTeX file.
     *
     * @return bool     true if the PDF file was written, else false
     */
    public function buildPdf() : bool
    {
        $this->errors = [];

        if (file_exists($this->filename.'.pdf')) {
            if (! unlink($this->filename.'.pdf')) {
                $this->errors['pdf'] = 'Old PDF file could not be deleted';
                return false;
            }
        }

        // nonstopmode shows the errors and does not wait for interaction
        // batchmode would show no error/warnings at all
        // without the output-directory pdflatex would put the files
        // (*.log, *.aux, *.pdf) into the current working directory
        $command = $this->command
                .' --interaction=nonstopmode --output-directory='
                .dirname($this->filename).' '.$this->filename;

        // execute multiple times to resolve all document references
        exec($command);
        exec($command);
        exec($command, $output, $return);

        // 127 == command not found
        if ($return == 127) {
            $this->errors['pdflatex'] = 'Pdflatex is not installed or not within the $PATH!';
            return false;
        }

        $this->log = implode("\n", $output);
        if ($return != 0) {
            // pdflatex returned an exit state > 0,
            // return the complete output for debugging
            $this->errors['pdflatex'] = $this->log;
        }

        // remove unwanted additional files
        @unlink($this->filename.'.out');
        @unlink($this->filename.'.aux');
        @unlink($this->filename.'.log');

        // good hint for missing packages
        $missingFonts = dirname($this->filename).DIRECTORY_SEPARATOR.'missfont.log';
        if (file_exists($missingFonts)) {
            $this->errors['missingFonts'] = file_get_contents($missingFonts);
            @unlink($missingFonts);
        }

        // sometimes the texput.log is generated, e.g. when the input file does not exist
        @unlink(dirname($this->filename).DIRECTORY_SEPARATOR.'texput.log');

        return file_exists($this->filename.'.pdf');
    }

    /**
     * Retrieve all messages from the last PDF build if some fatal error occured.
     *
     * @return array
     */
    public function getErrors() : array
    {
        return $this->errors;
    }

    /**
     * Retrieve the console output generated by pdflatex, can contain warnings
     * like missing fonts or smaller tex errors that were ignored by the engine.
     *
     * @return string
     */
    public function getLog() : string
    {
        return $this->log;
    }

    /**
     * Retrieve the autogenerated or configured file name.
     *
     * @return string
     */
    public function getFilename() :string
    {
        return $this->filename;
    }

    /**
     * Returns the name of the generated PDF file.
     *
     * @return string   the pdf file name or NULL if it was not (yet) generated
     */
    public function getPdfFile() : ?string
    {
        $filename = $this->filename.'.pdf';
        return file_exists($filename) ? $filename : null;
    }
}
